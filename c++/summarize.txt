虚函数:
    1.基类指针只能操作从基类继承下来的资源 动态绑定需要虚函数
    2.指针指向虚函数表动态绑定虚函数
抽象类:
    1.含有纯虚函数的类
    2.无法实例化
unorder_map:
    哈希表+桶
    处理哈希冲突：大于8用红黑树，小于8用链表
sizeof:
    空类大小：1
    字节对齐：和最大对齐
    虚函数：8（虚函数指针）
    sizeof(array):数组大小
    sizeof(ptr): 指针大小
指针：
    野指针：未被初始化的指针
    空指针：赋值为0的指针
    指针指向局部变量，局部变量释放后指针随机指向一个地址
    
智能指针：
    autp_ptr:所有权式剥夺原指针所有权存在潜在内存崩溃
    unique_ptr:独占式所有权，将其他unique_ptr赋值编译不过 move转移所有权
(boost库的boost::scoped_ptr也是一个独占性智能指针，但是他不允许转移所有权，从始而终都只对一个资源负责，他更安全谨慎
，应用范围也更狭窄) 
    shared_ptr:共享式指针，维护一个计数器，新的指针指向加1，指针release减一 没有指针引用时释放, 构造函数一个指针指
向计数器资源， 如果两个shared_ptr通过同一个指针构造会释放两次造成内存错误
    weak_ptr:指向shared_ptr管理的对象
回调函数:
    在对象发生事件后调用函数实现见callback.cc
内联函数:
    对编译器只是一种建议，如果函数规模过大，即使声明内联函数编译器也会将其看作普通函数对待，一般内联函数不超过5行，内联
函数内不能用复杂的控制语句，如循环和switch
    内联函数和宏定义的区别：宏是用预处理器对宏进行替代，内联函数是编译器控制实现，内联函数是真正的函数，像宏一样展开，取
消函数参数压栈过程
内存分配：
    栈区 由编译器自动分配和释放 局部变量 函数参数 返回数据 返回地址
    用户申请的内存存在堆区，由用户手动释放
    全局变量 静态变量 常量 已初始化的存放在data区 未初始化的存放在bss区 在全局区
    代码区存放函数体
    常量区存放常量字符串
    地址由低到高： 代码区->全局区->堆区->共享区->栈区->内核空间